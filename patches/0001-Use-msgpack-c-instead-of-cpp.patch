From 5af52f0240578449353ba07b29b0f739badb2f9f Mon Sep 17 00:00:00 2001
From: Anatolii Sakhnik <sakhnik@gmail.com>
Date: Wed, 14 Apr 2021 22:08:34 +0300
Subject: [PATCH] Use msgpack-c instead of cpp

---
 CMakeLists.txt        |   2 +
 src/Input.cpp         |  18 ++++----
 src/MsgPackRpc.cpp    |  53 ++++++++++++++-------
 src/MsgPackRpc.hpp    |  13 +++---
 src/RedrawHandler.cpp | 104 ++++++++++++++++++++++--------------------
 src/RedrawHandler.hpp |  18 ++++----
 src/Renderer.cpp      |  18 ++++----
 7 files changed, 128 insertions(+), 98 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 6a85203..aa9280c 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,6 +6,7 @@ set(VERSION 0.0.1-rc3)
 find_package(Threads)
 find_package(PkgConfig REQUIRED) 
 pkg_check_modules(LIBUV REQUIRED IMPORTED_TARGET libuv)
+pkg_check_modules(MSGPACK REQUIRED IMPORTED_TARGET msgpack)
 pkg_check_modules(SDL2 REQUIRED IMPORTED_TARGET sdl2)
 pkg_check_modules(CAIRO REQUIRED IMPORTED_TARGET cairo)
 pkg_check_modules(PANGO REQUIRED IMPORTED_TARGET pango)
@@ -29,6 +30,7 @@ set_target_properties(nvim-sdl2 PROPERTIES
 target_link_libraries(nvim-sdl2 PUBLIC
     ${CMAKE_THREAD_LIBS_INIT}
     PkgConfig::LIBUV
+    PkgConfig::MSGPACK
     PkgConfig::SDL2
     PkgConfig::CAIRO
     PkgConfig::PANGO
diff --git a/src/Input.cpp b/src/Input.cpp
index 4d72b12..25e7c64 100644
--- a/src/Input.cpp
+++ b/src/Input.cpp
@@ -2,6 +2,7 @@
 #include "MsgPackRpc.hpp"
 #include "Renderer.hpp"
 #include <iostream>
+#include <sstream>
 #include <SDL2/SDL.h>
 
 
@@ -27,7 +28,7 @@ void Input::Start()
         self->_PollEvents();
     };
 
-    ::uv_timer_start(&_timer, on_timeout, 10, 10);
+    ::uv_timer_start(&_timer, on_timeout, 50, 50);
 }
 
 void Input::_OnInput(std::string_view input)
@@ -35,18 +36,19 @@ void Input::_OnInput(std::string_view input)
     size_t input_size = input.size();
     _rpc->Request(
         [&](MsgPackRpc::PackerT &pk) {
-            pk.pack("nvim_input");
-            pk.pack_array(1);
-            pk.pack(input);
+            std::string_view nvim_input("nvim_input");
+            msgpack_pack_str_with_body(&pk, nvim_input.data(), nvim_input.size());
+            msgpack_pack_array(&pk, 1);
+            msgpack_pack_str_with_body(&pk, input.data(), input.size());
         },
-        [=](const msgpack::object &err, const msgpack::object &resp) {
-            if (!err.is_nil())
+        [=](const msgpack_object &err, const msgpack_object &resp) {
+            if (err.type != MSGPACK_OBJECT_NIL)
             {
                 std::ostringstream oss;
-                oss << "Input error: " << err;
+                //oss << "Input error: " << err;
                 throw std::runtime_error(oss.str());
             }
-            size_t consumed = resp.as<size_t>();
+            size_t consumed = resp.via.i64;
             if (consumed < input_size)
             {
                 std::cerr << "[input] Consumed " << consumed << "/" << input_size << " bytes" << std::endl;
diff --git a/src/MsgPackRpc.cpp b/src/MsgPackRpc.cpp
index ce9d923..2158578 100644
--- a/src/MsgPackRpc.cpp
+++ b/src/MsgPackRpc.cpp
@@ -1,4 +1,5 @@
 #include "MsgPackRpc.hpp"
+#include <memory>
 
 
 MsgPackRpc::MsgPackRpc(uv_pipe_t *stdin_pipe, uv_pipe_t *stdout_pipe)
@@ -6,11 +7,12 @@ MsgPackRpc::MsgPackRpc(uv_pipe_t *stdin_pipe, uv_pipe_t *stdout_pipe)
     , _stdout_pipe{stdout_pipe}
 {
     _stdout_pipe->data = this;
+    msgpack_unpacker_init(&_unp, 65536);
 
     auto alloc_buffer = [](uv_handle_t *handle, size_t len, uv_buf_t *buf) {
         MsgPackRpc *self = reinterpret_cast<MsgPackRpc*>(handle->data);
-        self->_unp.reserve_buffer(len);
-        buf->base = self->_unp.buffer();
+        msgpack_unpacker_reserve_buffer(&self->_unp, len);
+        buf->base = msgpack_unpacker_buffer(&self->_unp);
         buf->len = len;
     };
 
@@ -32,15 +34,29 @@ void MsgPackRpc::Request(PackRequestT pack_request, OnResponseT on_response)
 
     struct Write : uv_write_t
     {
-        msgpack::sbuffer buffer;
+        msgpack_sbuffer buffer;
+
+        Write()
+        {
+            msgpack_sbuffer_init(&buffer);
+        }
+
+        ~Write()
+        {
+            msgpack_sbuffer_destroy(&buffer);
+        }
+
+        Write(const Write &) = delete;
+        Write& operator=(const Write &) = delete;
     };
     std::unique_ptr<Write> w{new Write};
 
     // serializes multiple objects using msgpack::packer.
-    msgpack::packer<msgpack::sbuffer> pk(&w->buffer);
-    pk.pack_array(4);
-    pk.pack(0);
-    pk.pack(it->first);
+    msgpack_packer pk;
+    msgpack_packer_init(&pk, &w->buffer, msgpack_sbuffer_write);
+    msgpack_pack_array(&pk, 4);
+    msgpack_pack_int(&pk, 0);
+    msgpack_pack_int(&pk, it->first);
     pack_request(pk);
 
 
@@ -50,32 +66,35 @@ void MsgPackRpc::Request(PackRequestT pack_request, OnResponseT on_response)
     };
 
     uv_buf_t buf;
-    buf.base = w->buffer.data();
-    buf.len = w->buffer.size();
+    buf.base = w->buffer.data;
+    buf.len = w->buffer.size;
 
     uv_write(w.release(), reinterpret_cast<uv_stream_t*>(_stdin_pipe), &buf, 1, cb);
 }
 
 void MsgPackRpc::_handle_data(const char *data, size_t length)
 {
-    _unp.buffer_consumed(length);
+    msgpack_unpacker_buffer_consumed(&_unp, length);
+
+    msgpack_unpacked result;
+    msgpack_unpacked_init(&result);
 
-    msgpack::unpacked result;
-    while (_unp.next(result))
+    while (msgpack_unpacker_next(&_unp, &result))
     {
-        msgpack::object obj{result.get()};
+        msgpack_object obj = result.data;
         const auto &arr = obj.via.array;
-        if (arr.ptr[0] == 1)
+        if (arr.ptr[0].via.i64 == 1)
         {
             // Response
-            auto it = _requests.find(arr.ptr[1].as<uint32_t>());
+            auto it = _requests.find(arr.ptr[1].via.u64);
             it->second(arr.ptr[2], arr.ptr[3]);
             _requests.erase(it);
         }
-        else if (arr.ptr[0] == 2)
+        else if (arr.ptr[0].via.i64 == 2)
         {
             // Notification
-            _on_notification(arr.ptr[1].as<std::string_view>(), arr.ptr[2]);
+            auto method = arr.ptr[1].via.str;
+            _on_notification({method.ptr, method.size}, arr.ptr[2]);
         }
     }
 }
diff --git a/src/MsgPackRpc.hpp b/src/MsgPackRpc.hpp
index 0ba200d..77128e1 100644
--- a/src/MsgPackRpc.hpp
+++ b/src/MsgPackRpc.hpp
@@ -1,8 +1,9 @@
 #pragma once
 
 #include <functional>
-#include <string>
-#include <msgpack.hpp>
+#include <string_view>
+#include <map>
+#include <msgpack.h>
 #include <uv.h>
 
 
@@ -11,16 +12,16 @@ class MsgPackRpc
 public:
     MsgPackRpc(uv_pipe_t *stdin_pipe, uv_pipe_t *stdout_pipe);
 
-    using OnNotificationT = std::function<void(std::string_view, msgpack::object)>;
+    using OnNotificationT = std::function<void(std::string_view, const msgpack_object &)>;
 
     void OnNotifications(OnNotificationT on_notification)
     {
         _on_notification = on_notification;
     }
 
-    using PackerT = msgpack::packer<msgpack::sbuffer>;
+    using PackerT = msgpack_packer;
     using PackRequestT = std::function<void(PackerT &)>;
-    using OnResponseT = std::function<void(const msgpack::object &err, const msgpack::object &resp)>;
+    using OnResponseT = std::function<void(const msgpack_object &err, const msgpack_object &resp)>;
 
     void Request(PackRequestT pack_request, OnResponseT on_response);
 
@@ -28,7 +29,7 @@ private:
     OnNotificationT _on_notification;
     uv_pipe_t *_stdin_pipe;
     uv_pipe_t *_stdout_pipe;
-    msgpack::unpacker _unp;
+    msgpack_unpacker _unp;
     uint32_t _seq = 0;
     std::map<uint32_t, OnResponseT> _requests;
 
diff --git a/src/RedrawHandler.cpp b/src/RedrawHandler.cpp
index 4f78f8a..1bf612e 100644
--- a/src/RedrawHandler.cpp
+++ b/src/RedrawHandler.cpp
@@ -3,6 +3,7 @@
 #include "Renderer.hpp"
 #include "Utils.hpp"
 #include <iostream>
+#include <sstream>
 
 
 RedrawHandler::RedrawHandler(MsgPackRpc *rpc, Renderer *renderer)
@@ -14,35 +15,38 @@ RedrawHandler::RedrawHandler(MsgPackRpc *rpc, Renderer *renderer)
 void RedrawHandler::AttachUI()
 {
     _rpc->OnNotifications(
-        [this] (std::string_view method, const msgpack::object &obj) {
+        [this] (std::string_view method, const msgpack_object &obj) {
             _OnNotification(method, obj);
         }
     );
 
     _rpc->Request(
         [this](auto &pk) {
-            pk.pack("nvim_ui_attach");
-            pk.pack_array(3);
-            pk.pack(_renderer->GetWidth());
-            pk.pack(_renderer->GetHeight());
-            pk.pack_map(2);
-            pk.pack("rgb");
-            pk.pack(true);
-            pk.pack("ext_linegrid");
-            pk.pack(true);
+            std::string_view nvim_ui_attach("nvim_ui_attach");
+            msgpack_pack_str_with_body(&pk, nvim_ui_attach.data(), nvim_ui_attach.size());
+            msgpack_pack_array(&pk, 3);
+            msgpack_pack_int(&pk, _renderer->GetWidth());
+            msgpack_pack_int(&pk, _renderer->GetHeight());
+            msgpack_pack_map(&pk, 2);
+            std::string_view rgb("rgb");
+            msgpack_pack_str_with_body(&pk, rgb.data(), rgb.size());
+            msgpack_pack_true(&pk);
+            std::string_view ext_linegrid("ext_linegrid");
+            msgpack_pack_str_with_body(&pk, ext_linegrid.data(), ext_linegrid.size());
+            msgpack_pack_true(&pk);
         },
-        [](const msgpack::object &err, const auto &resp) {
-            if (!err.is_nil())
+        [](const msgpack_object &err, const msgpack_object &resp) {
+            if (err.type != MSGPACK_OBJECT_NIL)
             {
                 std::ostringstream oss;
-                oss << "Failed to attach UI " << err << std::endl;
+                //oss << "Failed to attach UI " << err << std::endl;
                 throw std::runtime_error(oss.str());
             }
         }
     );
 }
 
-void RedrawHandler::_OnNotification(std::string_view method, const msgpack::object &obj)
+void RedrawHandler::_OnNotification(std::string_view method, const msgpack_object &obj)
 {
     if (method != "redraw")
     {
@@ -50,7 +54,7 @@ void RedrawHandler::_OnNotification(std::string_view method, const msgpack::obje
         return;
     }
 
-    auto for_each_event = [](const msgpack::object_array &event, const auto &handler) {
+    auto for_each_event = [](const msgpack_object_array &event, const auto &handler) {
         for (size_t j = 1; j < event.size; ++j)
         {
             const auto &inst = event.ptr[j].via.array;
@@ -62,7 +66,7 @@ void RedrawHandler::_OnNotification(std::string_view method, const msgpack::obje
     for (size_t i = 0; i < arr.size; ++i)
     {
         const auto &event = arr.ptr[i].via.array;
-        std::string_view subtype = event.ptr[0].as<std::string_view>();
+        std::string_view subtype(event.ptr[0].via.str.ptr, event.ptr[0].via.str.size);
         if (subtype == "flush")
         {
             _renderer->Flush();
@@ -94,8 +98,8 @@ void RedrawHandler::_OnNotification(std::string_view method, const msgpack::obje
         else if (subtype == "default_colors_set")
         {
             const auto &inst = event.ptr[1].via.array;
-            unsigned fg = inst.ptr[0].as<unsigned>();
-            unsigned bg = inst.ptr[1].as<unsigned>();
+            unsigned fg = inst.ptr[0].via.i64;
+            unsigned bg = inst.ptr[1].via.i64;
             _renderer->DefaultColorSet(fg, bg);
         }
         else if (subtype == "grid_resize")
@@ -125,82 +129,82 @@ void RedrawHandler::_OnNotification(std::string_view method, const msgpack::obje
     }
 }
 
-void RedrawHandler::_GridCursorGoto(const msgpack::object_array &event)
+void RedrawHandler::_GridCursorGoto(const msgpack_object_array &event)
 {
-    int grid = event.ptr[0].as<int>();
+    int grid = event.ptr[0].via.i64;
     if (grid != 1)
         throw std::runtime_error("Multigrid not supported");
-    int row = event.ptr[1].as<int>();
-    int col = event.ptr[2].as<int>();
+    int row = event.ptr[1].via.i64;
+    int col = event.ptr[2].via.i64;
     _renderer->GridCursorGoto(row, col);
 }
 
-void RedrawHandler::_GridLine(const msgpack::object_array &event)
+void RedrawHandler::_GridLine(const msgpack_object_array &event)
 {
-    int grid = event.ptr[0].as<int>();
+    int grid = event.ptr[0].via.i64;
     if (grid != 1)
         throw std::runtime_error("Multigrid not supported");
 
-    int row = event.ptr[1].as<int>();
-    int col = event.ptr[2].as<int>();
+    int row = event.ptr[1].via.i64;
+    int col = event.ptr[2].via.i64;
     const auto &cells = event.ptr[3].via.array;
     unsigned hl_id = 0;
 
     for (size_t c = 0; c < cells.size; ++c)
     {
         const auto &cell = cells.ptr[c].via.array;
-        std::string_view chars = cell.ptr[0].as<std::string_view>();
+        std::string_view chars(cell.ptr[0].via.str.ptr, cell.ptr[0].via.str.size);
         if (cell.size > 1)
-            hl_id = cell.ptr[1].as<unsigned>();
+            hl_id = cell.ptr[1].via.i64;
         // if repeat is greater than 1, we are guaranteed to send an hl_id
         // https://github.com/neovim/neovim/blob/master/src/nvim/api/ui.c#L483
         int repeat = 1;
         if (cell.size > 2)
-            repeat = cell.ptr[2].as<int>();
+            repeat = cell.ptr[2].via.i64;
 
         _renderer->GridLine(row, col, chars, hl_id, repeat);
         col += repeat;
     }
 }
 
-void RedrawHandler::_GridScroll(const msgpack::object_array &event)
+void RedrawHandler::_GridScroll(const msgpack_object_array &event)
 {
-    int grid = event.ptr[0].as<int>();
+    int grid = event.ptr[0].via.i64;
     if (grid != 1)
         throw std::runtime_error("Multigrid not supported");
-    int top = event.ptr[1].as<int>();
-    int bot = event.ptr[2].as<int>();
-    int left = event.ptr[3].as<int>();
-    int right = event.ptr[4].as<int>();
-    int rows = event.ptr[5].as<int>();
-    int cols = event.ptr[6].as<int>();
+    int top = event.ptr[1].via.i64;
+    int bot = event.ptr[2].via.i64;
+    int left = event.ptr[3].via.i64;
+    int right = event.ptr[4].via.i64;
+    int rows = event.ptr[5].via.i64;
+    int cols = event.ptr[6].via.i64;
     if (cols)
         throw std::runtime_error("Column scrolling not expected");
 
     _renderer->GridScroll(top, bot, left, right, rows);
 }
 
-void RedrawHandler::_GridClear(const msgpack::object_array &event)
+void RedrawHandler::_GridClear(const msgpack_object_array &event)
 {
-    int grid = event.ptr[0].as<int>();
+    int grid = event.ptr[0].via.i64;
     if (grid != 1)
         throw std::runtime_error("Multigrid not supported");
     _renderer->GridClear();
 }
 
-void RedrawHandler::_HlAttrDefine(const msgpack::object_array &event)
+void RedrawHandler::_HlAttrDefine(const msgpack_object_array &event)
 {
-    unsigned hl_id = event.ptr[0].as<unsigned>();
+    unsigned hl_id = event.ptr[0].via.i64;
     const auto &rgb_attr = event.ptr[1].via.map;
 
     HlAttr attr;
     for (size_t i = 0; i < rgb_attr.size; ++i)
     {
-        std::string_view key{rgb_attr.ptr[i].key.as<std::string_view>()};
+        std::string_view key{rgb_attr.ptr[i].key.via.str.ptr, rgb_attr.ptr[i].key.via.str.size};
         if (key == "foreground")
-            attr.fg = rgb_attr.ptr[i].val.as<unsigned>();
+            attr.fg = rgb_attr.ptr[i].val.via.i64;
         else if (key == "background")
-            attr.bg = rgb_attr.ptr[i].val.as<unsigned>();
+            attr.bg = rgb_attr.ptr[i].val.via.i64;
         // nvim api docs state that boolean keys here are only sent if true
         else if (key == "reverse")
             attr.flags |= HlAttr::F_REVERSE;
@@ -219,18 +223,18 @@ void RedrawHandler::_HlAttrDefine(const msgpack::object_array &event)
     _renderer->HlAttrDefine(hl_id, attr);
 }
 
-void RedrawHandler::_GridResize(const msgpack::object_array &event)
+void RedrawHandler::_GridResize(const msgpack_object_array &event)
 {
-    int grid = event.ptr[0].as<int>();
+    int grid = event.ptr[0].via.i64;
     if (grid != 1)
         throw std::runtime_error("Multigrid not supported");
-    int width = event.ptr[1].as<int>();
-    int height = event.ptr[2].as<int>();
+    int width = event.ptr[1].via.i64;
+    int height = event.ptr[2].via.i64;
     _renderer->GridResize(width, height);
 }
 
-void RedrawHandler::_ModeChange(const msgpack::object_array &event)
+void RedrawHandler::_ModeChange(const msgpack_object_array &event)
 {
-    auto mode = event.ptr[0].as<std::string_view>();
+    std::string_view mode(event.ptr[0].via.str.ptr, event.ptr[0].via.str.size);
     _renderer->ModeChange(mode);
 }
diff --git a/src/RedrawHandler.hpp b/src/RedrawHandler.hpp
index 87c1737..393b6a8 100644
--- a/src/RedrawHandler.hpp
+++ b/src/RedrawHandler.hpp
@@ -1,7 +1,7 @@
 #pragma once
 
 #include <string_view>
-#include <msgpack/object_fwd.hpp>
+#include <msgpack/object.h>
 
 
 class MsgPackRpc;
@@ -19,13 +19,13 @@ private:
     MsgPackRpc *_rpc;
     Renderer *_renderer;
 
-    void _OnNotification(std::string_view method, const msgpack::object &obj);
+    void _OnNotification(std::string_view method, const msgpack_object &obj);
 
-    void _GridCursorGoto(const msgpack::object_array &event);
-    void _GridLine(const msgpack::object_array &event);
-    void _GridScroll(const msgpack::object_array &event);
-    void _GridClear(const msgpack::object_array &event);
-    void _HlAttrDefine(const msgpack::object_array &event);
-    void _GridResize(const msgpack::object_array &event);
-    void _ModeChange(const msgpack::object_array &event);
+    void _GridCursorGoto(const msgpack_object_array &event);
+    void _GridLine(const msgpack_object_array &event);
+    void _GridScroll(const msgpack_object_array &event);
+    void _GridClear(const msgpack_object_array &event);
+    void _HlAttrDefine(const msgpack_object_array &event);
+    void _GridResize(const msgpack_object_array &event);
+    void _ModeChange(const msgpack_object_array &event);
 };
diff --git a/src/Renderer.cpp b/src/Renderer.cpp
index 58b6b2e..05255e9 100644
--- a/src/Renderer.cpp
+++ b/src/Renderer.cpp
@@ -2,6 +2,7 @@
 #include "MsgPackRpc.hpp"
 #include "Painter.hpp"
 #include <iostream>
+#include <sstream>
 #include <chrono>
 
 
@@ -296,17 +297,18 @@ void Renderer::OnResized()
         new_width != static_cast<int>(_lines[0].text.size()))
     {
         _rpc->Request(
-            [&](auto &pk) {
-                pk.pack("nvim_ui_try_resize");
-                pk.pack_array(2);
-                pk.pack(new_width);
-                pk.pack(new_height);
+            [&](msgpack_packer &pk) {
+                std::string_view try_resize("nvim_ui_try_resize");
+                msgpack_pack_str_with_body(&pk, try_resize.data(), try_resize.size());
+                msgpack_pack_array(&pk, 2);
+                msgpack_pack_int(&pk, new_width);
+                msgpack_pack_int(&pk, new_height);
             },
-            [](const msgpack::object &err, const auto &resp) {
-                if (!err.is_nil())
+            [](const msgpack_object &err, const msgpack_object &resp) {
+                if (err.type != MSGPACK_OBJECT_NIL)
                 {
                     std::ostringstream oss;
-                    oss << "Failed to resize UI " << err << std::endl;
+                    //oss << "Failed to resize UI " << err << std::endl;
                     throw std::runtime_error(oss.str());
                 }
             }
-- 
2.31.1

