diff --git a/src/BaseTexture.cpp b/src/BaseTexture.cpp
index 77ac25c..4784ad1 100644
--- a/src/BaseTexture.cpp
+++ b/src/BaseTexture.cpp
@@ -1,4 +1,5 @@
 #include "BaseTexture.hpp"
+#include "Logger.hpp"
 
 bool BaseTexture::TakeRedrawToken(uint32_t token)
 {
@@ -8,3 +9,8 @@ bool BaseTexture::TakeRedrawToken(uint32_t token)
     _redraw_tokens.erase(it, _redraw_tokens.end());
     return true;
 }
+
+void BaseTexture::Log(const char *msg)
+{
+    Logger().info("{} {} = {}", (void*)this, msg, _refcount);
+}
diff --git a/src/BaseTexture.hpp b/src/BaseTexture.hpp
index b332e9e..c31fd4d 100644
--- a/src/BaseTexture.hpp
+++ b/src/BaseTexture.hpp
@@ -19,11 +19,13 @@ public:
     void IncRef(bool inc)
     {
         _refcount += inc ? 1 : -1;
+        Log(inc ? "inc" : "dec");
     }
 
     void SetVisible(bool visible)
     {
         _refcount += visible ? VISIBLE_INCREMENT : -VISIBLE_INCREMENT;
+        Log(visible ? "show" : "hide");
     }
 
     bool IsVisible() const
@@ -40,5 +42,7 @@ private:
     std::vector<uint32_t> _redraw_tokens;
     bool _destroy = false;
     int _refcount = 0;
-    static const int VISIBLE_INCREMENT = 0; //0x10000;
+    static const int VISIBLE_INCREMENT = 10000;
+
+    void Log(const char *msg);
 };
diff --git a/src/GGrid.cpp b/src/GGrid.cpp
index 38fd412..8e8f7f4 100644
--- a/src/GGrid.cpp
+++ b/src/GGrid.cpp
@@ -128,21 +128,37 @@ void GGrid::Present(int width, int height, uint32_t token)
 
     // First remove outdated textures
     auto removeOutdated = [&] {
-        auto it = std::partition(_textures.begin(), _textures.end(), [](auto &t) { return t->IsAlive(); });
-        for (auto it2 = it; it2 != _textures.end(); ++it2)
+        auto it_visible_end = std::partition(_textures.begin(), _textures.end(), [](auto &t) { return t->IsVisible(); });
+        auto it_alive_end = std::partition(it_visible_end, _textures.end(), [](auto &t) { return t->IsAlive(); });
+
+        for (auto it = it_visible_end; it != it_alive_end; ++it)
         {
-            Texture *texture = static_cast<Texture *>(it2->get());
-            if (texture->widget)
+            Texture *texture = static_cast<Texture *>(it->get());
+            if (texture->widget && gtk_widget_get_parent(texture->widget) == _grid)
             {
+                g_object_ref(G_OBJECT(texture->widget));
                 gtk_fixed_remove(GTK_FIXED(_grid), texture->widget);
+            }
+        }
+
+        for (auto it = it_alive_end; it != _textures.end(); ++it)
+        {
+            Texture *texture = static_cast<Texture *>(it->get());
+            if (texture->widget)
+            {
+                if (gtk_widget_get_parent(texture->widget) == _grid)
+                    gtk_fixed_remove(GTK_FIXED(_grid), texture->widget);
+                else
+                    g_object_unref(G_OBJECT(texture->widget));
                 texture->widget = nullptr;
             }
         }
-        _textures.erase(it, _textures.end());
+
+        _textures.erase(it_alive_end, _textures.end());
     };
     removeOutdated();
 
-    size_t texture_count = 0;
+    ssize_t texture_count = 0;
 
     for (int row = 0, rowN = renderer->GetGridLines().size();
          row < rowN; ++row)
@@ -169,14 +185,16 @@ void GGrid::Present(int width, int height, uint32_t token)
                 _textures.push_back(texture.texture);
             }
 
-            if (t->TakeRedrawToken(token))
+            if (t->TakeRedrawToken(token) && t->IsVisible())
             {
                 gtk_fixed_move(GTK_FIXED(_grid), t->widget, x, y);
             }
         }
     }
 
-    assert(texture_count == _textures.size() && "Texture count consistency");
+    Logger().info("textures = {}", _textures.size());
+    //auto visible_texture_count = std::count_if(_textures.begin(), _textures.end(), [](auto &t) { return t->IsVisible(); });
+    //assert(texture_count == visible_texture_count && "Texture count consistency");
 
     _cursor->Move();
     _pointer.Update(renderer->IsBusy(), _grid);
